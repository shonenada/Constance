内存管理
===================

7.1 分页机制

7.1.1 分页介绍

32 位 x86 处理器最大可支持 4GB 的虚拟地址空间。（但通过 PAE 技术可以使地址空间超过 4GB）。
在 Constance 中，采用了纯分页的内存管理。分页管理允许操作系统能够将多个地址空间映射到相同的物理内存上，还能够对内存提供保护，限制每个进程只能访问自己的内存地址空间。
分页实现是由 MMU 完成，它根据当前的页目的和页表，将虚拟地址转换成物理地址。每个进程只能够访问、修改自己进程的页面。
按照 x86 分页机制，内存被划分为 4kb 或者 4mb 的内存区域，每一个内存区域称为物理页。页表每一个页表项负责表示虚拟页到物理页的映射。
每个页表都包含 1024 个页表项（称为 PTE，Page Table Entry，页表实体），每个 PTE 记录一个从虚拟地址到物理地址的映射。页目录也同样也是 1024 项，每一个表项（PDE， Page Directory Entry）保存一个页表。

页目录项结构：

31 - 12 , 11  - 0
   ppn     flags

其中 ppn 表示该表项所对应页表的页号。
flags 为对该页目录项的标志:
1.
2.

页表项的结构和页目录项结构相同。


7.1.2 地址翻译过程

如上文所述，32 位处理器用 32 个比特位来表示一个虚拟地址，虚拟地址的结构如下：

31 - 22 , 21 - 12 , 11 - 0
 Dir       Table    offset

虚拟地址高 10 位表示使用页目录中的哪一个页表。虚拟地址第 11 到 20 位表示的是使用页表中的哪一个页表项，而虚拟地址的低 12 位为偏移地址。

地址翻译过程为：

1、根据虚拟地址的高 10 位，取得对应的页目录项，页目录项 ppn 字段表示该页表的页号。如果页表不存在，抛出错误。
2、根据虚拟地址 11 ~ 20 位，在已得的页表中查到对应页表项，查到页表 ppn 字段值，和 offset 拼接，即得到对应的物理地址。


7.1.3 打开分页机制

1、创建页目录

如上文所述，虚拟地址翻译的第一步是在页目录中寻找到指定的页表。因此在分页机制打开之前，需要设置好页目录。
页目录本质是一个含有 1024 个元素的数组，每个元素占 4b，表示页表的地址与相关的目录项属性，因此在 32 位处理器上，可以直接使用 int 类型即 int pd[1024] = {0,}; 即可。
但为了代码可读性，Constance 中使用一个 4b 的结构来表示一个 PDE，结构定义如下：

struct pde {
    uint ppn:20;
    uint flags:9;
    uint avl:3;
};

2、初始化页目录

理论上，每一个页目录项都需要为其分配一个页表，但在 Constance 设计中，采用了懒惰的方式，即初始化时仅仅为第一个页目录项分配一个页表，其余目录项在需要的时候再为其分配页表。
与页目录相同，页表也是一个含有 1024 个 4b 大小元素的数组，同样为了代码可读性，Constance 设计中也为页表项创建一个结构：

struct pte {
  uint ppn:20;
  uint flags:9;
  uint avl:3;
};

第一个页表创建创建完毕后，将页目录的第一个元素 ppn 设为该页表的页号。

3、编写内存错误中断例程

根据需要，编写“缺页”和“错页”两种页面错误中断例程。并加载到中断处理向量表中。

4、载入页目录并打开分页机制

x86 处理器分页机制，会在 cr3 寄存器中寻找页目录地址。因此在正式进入分页机制之前，需要将设置好的页目录地址载入到 cr3 寄存器中。该过程可通过 mov 指令完成 mov cr3, eax 。
使 x86 处理器进入分页机制的标志为，cr0 寄存器的 PE 位置位，因此只需要从取出 cr0 的值，并置 PE （最高位）为 1 ，重新写入 cr0 寄存器即可。

7.1.4 分页错误


7.2 内存分配

